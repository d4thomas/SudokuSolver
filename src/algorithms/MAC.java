package algorithms;

import java.util.*;

import problems.CSPProblem;

/**
 * A generic solver for CSPs that implements the following techniques:
 * maintaining arc consistency (MAC) and minimum-remaining-values (MRV)
 * <p>
 * Note: MAC = backtracking search and dynamic arc consistency (AC-3)
 *
 * @param <X> the data type of variables.
 *            * * (e.g., for Sudoku, we use Square such as (1, 5) to
 *            name the squares of the 9x9 board, where the first number
 *            specifies the row and the second number specifies the column)
 * @param <V> the data type of values.
 *            (e.g., in Sudoku, values should be integers between 1 and 9)
 */
public abstract class MAC<X, V> {

    /**
     * The data type that represents an arc in the AC-3 algorithm.
     * Note that for a record, the equals() and hashCode()
     * methods are automatically generated by Java, making it
     * safe to use a record as a map key.
     * 
     * @param head head of the arc
     * @param tail tail of the arc
     * @param <X>
     */
    public record Arc<X>(X tail, X head) {
    }

    // Map all variables to their domains
    private Map<X, List<V>> allVariables;

    // Keep track of the variables that have been assigned so far
    private final Set<X> assigned;

    private final CSPProblem<X, V> problem;

    public MAC(CSPProblem<X, V> problem) {
        this.problem = problem;
        this.allVariables = problem.getAllVariables();
        // Populate the assigned set with any pre-assigned variables
        this.assigned = new HashSet<>(problem.getPreAssignedVariables());
    }

    /**
     * Implements the AC-3 (Arc Consistency 3) algorithm.
     *
     * @param arcs A queue of arcs that need to be checked for consistency
     * @return false if arc consistency could not be maintained (i.e.,
     *         a domain becomes empty),
     *         true otherwise
     */
    public boolean AC3(Queue<Arc<X>> arcs) {
        Set<Arc<X>> inQueue = new HashSet<>(arcs);
        while (!arcs.isEmpty()) {
            Arc<X> arc = arcs.poll();
            inQueue.remove(arc);
            X tail = arc.tail();
            X head = arc.head();
            if (revise(tail, head)) {
                if (allVariables.get(tail).isEmpty()) {
                    return false;
                }
                for (X neighbor : problem.getNeighborsOf(tail)) {
                    if (!neighbor.equals(head)) {
                        Arc<X> newArc = new Arc<>(neighbor, tail);
                        if (!inQueue.contains(newArc)) {
                            arcs.add(newArc);
                            inQueue.add(newArc);
                        }
                    }
                }
            }
        }
        return true;
    }

    /**
     * Performs the AC-3 algorithm as preprocessing before search begins.
     *
     * @return true or false
     */
    public boolean initAC3() {
        Queue<Arc<X>> arcs = new LinkedList<>();
        for (X v : allVariables.keySet()) {
            for (X n : problem.getNeighborsOf(v)) {
                arcs.add(new Arc<>(n, v));
            }
        }
        return AC3(arcs);
    }

    /**
     * An implementation of the maintaining arc consistency (MAC)
     * algorithm, which is essentially backtracking search plus
     * dynamic arc consistency.
     * 
     * @return true if a solution is found
     *         false otherwise
     */
    public boolean search() {
        X n = selectUnassigned();
        if (n == null) {
            return true;
        }
        assigned.add(n);
        while (!allVariables.get(n).isEmpty()) {
            // Select a value to be assigned to this variable
            V value = allVariables.get(n).removeFirst();
            // Make a deep clone of the nodeList in case to back track
            // later if needed
            Map<X, List<V>> allVariablesClone = deepClone();
            // Assign the selected 'value' to the variable n
            allVariables.get(n).clear();
            allVariables.get(n).add(value);
            Queue<Arc<X>> arcs = new LinkedList<>();
            // Get all the arcs that could potentially be affected by
            // this assignment, i.e., all the arcs where n is the head
            for (X nei : problem.getNeighborsOf(n)) {
                arcs.add(new Arc<>(nei, n));
            }
            // Perform initial constraint propagation using the AC-3
            // algorithm before the search begins
            if (AC3(arcs) && search()) {
                return true;
            } else {
                revert(allVariablesClone);
            }
        }
        assigned.remove(n);
        return false;
    }

    /**
     * Create a deep clone of the allVariables map to back track
     * in the future if needed.
     */
    public Map<X, List<V>> deepClone() {
        Map<X, List<V>> allVariablesClone = new HashMap<>();
        for (Map.Entry<X, List<V>> e : allVariables.entrySet()) {
            // Deep clone the domain list
            allVariablesClone.put(e.getKey(), new ArrayList<>(e.getValue()));
        }
        return allVariablesClone;
    }

    /**
     * Revert the allVariables map to the deep clone copy
     */
    public void revert(Map<X, List<V>> allVariablesClone) {
        allVariables = allVariablesClone;
    }

    public Map<X, List<V>> getAllVariables() {
        return allVariables;
    }

    /**
     * Check if the given variable has been assigned a value already.
     *
     * @param var the variable whose assignment will be checked
     * @return true if assigned, false otherwise
     */
    public boolean assigned(X var) {
        return assigned.contains(var);
    }

    /**
     * Implements the minimum remaining values (MRV) heuristic.
     * <p>
     * This method is used during a backtracking search to decide which unassigned
     * variable to consider next. The MRV heuristic selects the variable with
     * the fewest legal values remaining in its domain, helping reduce the branching
     * factor early in the search.
     *
     * @return the unassigned variable with the smallest domain;
     *         null if all variables have already been assigned.
     */
    public X selectUnassigned() {
        X minVar = null;
        int minSize = Integer.MAX_VALUE;
        for (X var : allVariables.keySet()) {
            if (!assigned(var)) {
                int size = allVariables.get(var).size();
                if (size < minSize) {
                    minSize = size;
                    minVar = var;
                }
            }
        }
        return minVar;
    }

    /**
     * Revise an arc to maintain arc consistency.
     *
     * @param tail tail of the arc
     * @param head head of the arc
     * @return false if no value is deleted, true otherwise
     */
    public abstract boolean revise(X tail, X head);
}